import sys
import os
import struct
from datetime import datetime

TABLE_DC70 = bytes([
    0x28, 0x2D, 0x91, 0x73, 0xF5, 0x06, 0xD6, 0xBA, 0xBF, 0xF3, 0x45, 0x3F, 0xF1, 0x61, 0xB1, 0xE9,
    0xE1, 0x98, 0x3D, 0x6F, 0x31, 0x0D, 0xAC, 0xB1, 0x08, 0x83, 0x9D, 0x0D, 0x10, 0xD1, 0x41, 0xF9,
    0x00, 0xBA, 0x1A, 0xCF, 0x13, 0x71, 0xE4, 0x86, 0x21, 0x2F, 0x22, 0xAA, 0xDD, 0x4C, 0x7F, 0x9B,
    0x1F, 0x9A, 0xD5, 0x49, 0xE9, 0x34, 0x89, 0x56, 0xA7, 0x96, 0x1B, 0x52, 0x67, 0x6A, 0x6F, 0x74,
    0xCD, 0x80, 0x45, 0xF3, 0xE7, 0x2A, 0x1D, 0x16, 0xB2, 0xF1, 0x54, 0xC8, 0x6C, 0x2B, 0x0D, 0xD4,
    0x65, 0xF7, 0xE3, 0x36, 0xD4, 0xA5, 0x3B, 0xD1, 0x79, 0x4C, 0x54, 0xF0, 0x2A, 0xB4, 0xB2, 0x56,
    0x45, 0x2E, 0xAB, 0x23, 0x65, 0xC3, 0x45, 0xA0, 0xC3, 0x92, 0x48, 0x9D, 0xEA, 0xDD, 0x31, 0x2C,
    0xE9, 0xE2, 0x10, 0x7B, 0x88, 0xC5, 0xFA, 0x74, 0xAD, 0x03, 0xB8, 0x9E, 0xD5, 0xF5, 0x6F, 0xDC,
    0xFA, 0x44, 0x49, 0x31, 0xF6, 0x83, 0x32, 0xFF, 0xC2, 0xB1, 0xE9, 0xE1, 0x98, 0x3D, 0x6F, 0x31,
    0x0D, 0xAC, 0xB1, 0x08, 0x83, 0x9D, 0x0D, 0x10, 0xD1, 0x41, 0xF9, 0x00, 0xBA, 0x1A, 0xCF, 0x13,
    0x71, 0xE4, 0x86, 0x21, 0x2F, 0x22, 0xAA, 0x6A, 0x35, 0xB1, 0x7E, 0xD1, 0xB5, 0xE7, 0xEC, 0x7A,
    0x6F, 0x26, 0x74, 0x0E, 0xDB, 0x27, 0x4C, 0xA5, 0xF1, 0x0E, 0x2D, 0x70, 0xC4, 0x40, 0x5D, 0x4F,
    0xDA, 0x9E, 0xC5, 0x49, 0x7B, 0xBD, 0xE8, 0xDF, 0xD8, 0x29, 0xB9, 0x16, 0x3D, 0x1A, 0xBA, 0xBF,
    0xDF, 0xD8, 0x29, 0xB9, 0x16, 0x3D, 0x1A, 0x76, 0xD0, 0x87, 0x9B, 0x2D, 0x0C, 0x7B, 0xD1, 0xE1,
    0xAD, 0xEE, 0xCA, 0xF4, 0x92, 0xDE, 0xE4, 0x76, 0x10, 0xDD, 0x2A, 0x52, 0xDC, 0x73, 0x4E, 0x54,
    0x8C, 0x30, 0x3D, 0x9A, 0xB2, 0x9B, 0xB8, 0x93, 0x29, 0x55, 0xFA, 0x7A, 0xC9, 0xDA, 0x10, 0x97,
])

TABLE_DD70 = bytes([
    0x0E, 0xDB, 0x27, 0x4C, 0xA5, 0xF1, 0x0E, 0x2D, 0x70, 0xC4, 0x40, 0x5D, 0x4F, 0xDA, 0xA0, 0xC3,
    0x92, 0x48, 0x9D, 0xEA, 0xDD, 0x31, 0x2C, 0xE9, 0xE2, 0x10, 0x22, 0xAA, 0xD8, 0x29, 0xB9, 0x16,
    0x3D, 0x1A, 0x76, 0xD0, 0x87, 0x9B, 0x2D, 0x0C, 0x7B, 0xD1, 0xE1, 0xAD, 0x9E, 0xC5, 0x49, 0x7B,
    0xBD, 0xE8, 0xDF, 0xEE, 0xCA, 0xF4, 0x92, 0xDE, 0xE4, 0x76, 0x10, 0xDD, 0x2A, 0x52, 0xDC, 0x73,
    0x4E, 0x54, 0x8C, 0x30, 0x3D, 0x9A, 0xB2, 0x9B, 0xB8, 0x93, 0x29, 0x55, 0xFA, 0x7A, 0xC9, 0xDA,
    0x10, 0x97, 0xE5, 0xB6, 0x23, 0x02, 0xDD, 0x38, 0x4C, 0x2C, 0xC4, 0x2D, 0x7F, 0x9B, 0x1F, 0x9A,
    0xD5, 0x49, 0xE9, 0x34, 0x89, 0x56, 0xA7, 0x96, 0x14, 0xBE, 0x2E, 0xC5, 0xB1, 0x7E, 0xD1, 0xB5,
    0xE7, 0xE6, 0xD5, 0xF5, 0x06, 0xD6, 0xBA, 0xBF, 0xF3, 0x45, 0x3F, 0xF1, 0x61, 0xDD, 0x54, 0xC8,
    0x2E, 0xAB, 0x7B, 0x88, 0xC5, 0xFA, 0x74, 0xAD, 0x03, 0xB8, 0x9E, 0xD5, 0xF5, 0x6F, 0x6C, 0x2B,
    0x0D, 0xD4, 0x65, 0xF7, 0xE3, 0x36, 0xD4, 0xA5, 0x3B, 0xD1, 0x79, 0x4C, 0x54, 0xF0, 0x2A, 0xB4,
    0xB2, 0x56, 0x45, 0xDC, 0xFA, 0x44, 0x49, 0x31, 0xF6, 0x83, 0x32, 0xFF, 0xC2, 0xB1, 0xE9, 0xE1,
    0x98, 0x3D, 0x6F, 0x31, 0x0D, 0xAC, 0xB1, 0x08, 0x83, 0x9D, 0x0D, 0x10, 0xD1, 0x41, 0xF9, 0x00,
    0xBA, 0x1A, 0xCF, 0x13, 0x71, 0xE4, 0x86, 0x21, 0x2F, 0x23, 0x65, 0xC3, 0x45, 0xA0, 0x1B, 0x52,
    0x67, 0x6A, 0x6F, 0x74, 0xEC, 0x7A, 0x6F, 0x26, 0x74, 0x0E, 0xDB, 0x27, 0x4C, 0xA5, 0xF1, 0x0E,
    0x2D, 0x70, 0xC4, 0x40, 0x5D, 0x4F, 0xDA, 0x9E, 0xC5, 0x49, 0x7B, 0xBD, 0xE8, 0xDF, 0xD8, 0x29,
    0xB9, 0x16, 0x3D, 0x1A, 0x76, 0xD0, 0x87, 0x9B, 0x2D, 0x0C, 0x7B, 0xD1, 0xE1, 0xAD, 0xEE, 0xCA,
])

TABLE_DE70 = bytes([
    0x6A, 0x35, 0xB1, 0x7E, 0xD1, 0xB5, 0xE7, 0xE6, 0xD5, 0xA9, 0x19, 0x0F, 0x28, 0x2D, 0xF4, 0xC3,
    0x92, 0x48, 0x9D, 0xEA, 0xDD, 0x31, 0x2C, 0xE9, 0xE2, 0x10, 0x91, 0x73, 0x4C, 0x3E, 0x08, 0x5F,
    0x47, 0xA9, 0xDF, 0x88, 0x9F, 0xD4, 0xCC, 0x69, 0x1F, 0x30, 0x9F, 0xE7, 0xCD, 0x80, 0x45, 0xF3,
    0xE7, 0x2A, 0x1D, 0x16, 0xB2, 0xF1, 0x6A, 0x35, 0x67, 0x6A, 0x6F, 0x74, 0xEC, 0x7A, 0x6F, 0x26,
    0x74, 0x92, 0xDE, 0xE4, 0x76, 0x10, 0xDD, 0x2A, 0x52, 0xDC, 0x73, 0x4E, 0x54, 0x8C, 0x30, 0x3D,
    0x9A, 0xB2, 0x9B, 0xB8, 0x93, 0x29, 0x55, 0xFA, 0x7A, 0xC9, 0xDA, 0x10, 0x97, 0xE5, 0xB6, 0x23,
    0x02, 0xDD, 0x38, 0x4C, 0x2C, 0xC4, 0x2D, 0x39, 0x5C, 0x36, 0x22, 0x9F, 0x91, 0x73, 0xF5, 0x06,
    0xD6, 0xBA, 0xBF, 0xF3, 0x45, 0x3F, 0xF1, 0x61, 0xDD, 0x4C, 0x7F, 0x9B, 0x1F, 0x9A, 0xD5, 0x49,
    0xE9, 0x34, 0x89, 0x56, 0xA7, 0x96, 0x14, 0xBE, 0x2E, 0xC5, 0x3E, 0x08, 0x5F, 0x47, 0xA9, 0xDF,
    0x88, 0x9F, 0xD4, 0xCC, 0x69, 0x1F, 0x30, 0x9F, 0xE7, 0xCD, 0x80, 0x45, 0xF3, 0xE7, 0x2A, 0x1D,
    0x16, 0xB2, 0xF1, 0x54, 0xC8, 0x6C, 0x2B, 0x0D, 0xD4, 0x65, 0xF7, 0xE3, 0x36, 0xD4, 0xA5, 0x3B,
    0xD1, 0x79, 0x4C, 0x54, 0xF0, 0x2A, 0xB4, 0xB2, 0x56, 0x45, 0x2E, 0xCA, 0xF4, 0x92, 0xDE, 0xE4,
    0x76, 0x10, 0xDD, 0x2A, 0x52, 0xDC, 0x73, 0x4E, 0x54, 0x8C, 0x30, 0x3D, 0x9A, 0xB2, 0x9B, 0xB8,
    0x93, 0x29, 0x55, 0xFA, 0x7A, 0xC9, 0xDA, 0x10, 0x97, 0xAB, 0x23, 0x65, 0xC3, 0x45, 0xA0, 0xC3,
    0x92, 0x48, 0x9D, 0xEA, 0xDD, 0x31, 0x2C, 0xE9, 0xE2, 0x10, 0x7B, 0x88, 0xC5, 0xFA, 0x74, 0xAD,
    0x03, 0xB8, 0x9E, 0xD5, 0xF5, 0x6F, 0xDC, 0xFA, 0x44, 0x49, 0x31, 0xF6, 0x83, 0x32, 0xFF, 0xC2,
])

TABLE_DF70 = bytes([
    0xA9, 0x19, 0x0F, 0x28, 0x2D, 0x1B, 0x52, 0x39, 0x5C, 0x36, 0x22, 0x9F, 0x91, 0x73, 0x6A, 0x35,
    0x67, 0x6A, 0x6F, 0x74, 0xEC, 0x7A, 0x6F, 0x26, 0x74, 0x0E, 0xDB, 0x27, 0x4C, 0xA5, 0xF1, 0x0E,
    0x2D, 0x70, 0xC4, 0x40, 0x5D, 0x4F, 0xDA, 0x9E, 0xC5, 0x49, 0x7B, 0xBD, 0xE8, 0xDF, 0xEE, 0xCA,
    0xF4, 0x92, 0xDE, 0xE4, 0x76, 0x10, 0xDD, 0x2A, 0x52, 0xDC, 0x73, 0x4E, 0x54, 0x8C, 0x30, 0x3D,
    0x9A, 0xB2, 0x9B, 0xB8, 0x93, 0x29, 0x55, 0xFA, 0x7A, 0xC9, 0xDA, 0x10, 0x97, 0xE5, 0xB6, 0x23,
    0x02, 0xDD, 0x38, 0x4C, 0x2C, 0xC4, 0x2D, 0x7F, 0x9B, 0x1F, 0x9A, 0xD5, 0x49, 0xE9, 0x34, 0x89,
    0x56, 0xA7, 0x96, 0x14, 0xBE, 0x2E, 0xC5, 0xB1, 0x7E, 0xD1, 0xB5, 0xE7, 0xE6, 0xD5, 0xF5, 0x06,
    0xD6, 0xBA, 0xBF, 0xF3, 0x45, 0x3F, 0xF1, 0x61, 0xDD, 0x4C, 0x3E, 0x08, 0x5F, 0x47, 0xA9, 0xDF,
    0x88, 0x9F, 0xD4, 0xCC, 0x69, 0x1F, 0x30, 0x9F, 0xE7, 0xCD, 0x80, 0x45, 0xF3, 0xE7, 0x2A, 0x1D,
    0x16, 0xB2, 0xF1, 0x54, 0xC8, 0x6C, 0x2B, 0x0D, 0xD4, 0x65, 0xF7, 0xE3, 0x36, 0xD4, 0xA5, 0x3B,
    0xD1, 0x79, 0x4C, 0x54, 0xF0, 0x2A, 0xB4, 0xB2, 0x56, 0x45, 0x2E, 0xAB, 0x7B, 0x88, 0xC5, 0xFA,
    0x74, 0xAD, 0x03, 0xB8, 0x9E, 0xD5, 0xF5, 0x6F, 0xDC, 0xFA, 0x44, 0x22, 0xAA, 0xD8, 0x29, 0xB9,
    0x16, 0x3D, 0x1A, 0x76, 0xD0, 0x87, 0x9B, 0x2D, 0x0C, 0x7B, 0xD1, 0xE1, 0xAD, 0xA9, 0x19, 0x0F,
    0x28, 0x2D, 0x1B, 0x52, 0x39, 0x5C, 0x36, 0x22, 0x9F, 0x49, 0x31, 0xF6, 0x83, 0x32, 0xFF, 0xC2,
    0xB1, 0xE9, 0xE1, 0x98, 0x3D, 0x6F, 0x31, 0x0D, 0xAC, 0xB1, 0x08, 0x83, 0x9D, 0x0D, 0x10, 0xD1,
    0x41, 0xF9, 0x00, 0xBA, 0x1A, 0xCF, 0x13, 0x71, 0xE4, 0x86, 0x21, 0x2F, 0x23, 0x65, 0xC3, 0x45,
])

def xor_decrypt_inplace(data: bytearray, table: bytes, start_index: int, length: int) -> None:
    idx = start_index
    for i in range(length):
        data[i] ^= table[idx]
        idx = (idx + 1) % 256

def lzss_decompress(src: bytes) -> bytes:
    if not src or len(src) < 8:
        return b''
    decompressed_size = struct.unpack_from('<I', src, 4)[0]
    if decompressed_size == 0:
        return b''
    output = bytearray(decompressed_size)
    src_pos = 8
    dst_pos = 0
    while dst_pos < decompressed_size:
        if src_pos >= len(src):
            break
        flags = src[src_pos]
        src_pos += 1
        for bit in range(8):
            if dst_pos >= decompressed_size:
                break
            if flags & 1:
                if src_pos >= len(src):
                    break
                output[dst_pos] = src[src_pos]
                src_pos += 1
                dst_pos += 1
            else:
                if src_pos + 2 > len(src):
                    break
                word = struct.unpack_from('<H', src, src_pos)[0]
                src_pos += 2
                length = (word & 0xF) + 2
                offset = word >> 4
                for _ in range(length):
                    if dst_pos >= decompressed_size:
                        break
                    output[dst_pos] = output[dst_pos - offset]
                    dst_pos += 1
            flags >>= 1
    return bytes(output)

def blit_with_wrapping_mask(dst: bytearray, src: bytes,
                            block_width: int, block_height: int,
                            mask: bytes, mask_width: int, mask_height: int,
                            use_less_than: bool) -> None:
    if not src or not dst:
        return
    mask_total = mask_width * mask_height
    start_row = (mask_height - 37 % mask_height) % mask_height
    start_col = (mask_width - 111 % mask_width) % mask_width
    row_offset = start_row * mask_width
    src_idx = 0
    dst_idx = 0
    for _ in range(block_height):
        col = start_col
        for _ in range(block_width):
            mask_idx = row_offset + col
            mask_val = mask[mask_idx]
            if use_less_than:
                if mask_val < 0x80:
                    dst[dst_idx*4:(dst_idx+1)*4] = src[src_idx*4:(src_idx+1)*4]
            else:
                if mask_val >= 0x80:
                    dst[dst_idx*4:(dst_idx+1)*4] = src[src_idx*4:(src_idx+1)*4]
            src_idx += 1
            dst_idx += 1
            col += 1
            if col >= mask_width:
                col = 0
        row_offset += mask_width
        if row_offset >= mask_total:
            row_offset = 0

def decrypt_and_decompress_resource(block: bytearray, block_size: int) -> tuple:
    xor_decrypt_inplace(block, TABLE_DD70, 13, block_size)
    header = struct.unpack_from('<19I', block, 0)
    param6 = header[6]
    param9 = header[9]
    param10 = header[10]
    compressed_size = header[17]
    filename_len = header[18]
    filename_start = 19 * 4
    filename_data = bytearray(block[filename_start : filename_start + filename_len])
    xor_decrypt_inplace(filename_data, TABLE_DC70, 59, filename_len)
    filename = filename_data.decode('utf-16-le', errors='replace').rstrip('\x00')
    mask_width = param6 % 16 + 16
    mask_height = param9 % 16 + 16
    mask_size = mask_width * mask_height
    mask = bytearray(mask_size)
    idx_96 = 96
    idx_11 = 11
    for i in range(mask_size):
        header_idx = (idx_11 + 1)
        if header_idx < 19:
            val = header[header_idx] & 0xFF
        else:
            val = 0
        mask[i] = TABLE_DE70[idx_96] ^ val
        idx_96 = (idx_96 + 1) % 256
        idx_11 = (idx_11 + 1) % 16
    block_width = param10 % 32 + 32
    half_size = (compressed_size + 1) // 2
    num_dwords = (half_size + 3) // 4
    block_height = (block_width + num_dwords - 1) // block_width
    total_size = 4 * block_width * block_height
    buf1 = bytearray(total_size)
    buf2 = bytearray(total_size)
    data_start = 76 + filename_len
    src1 = bytes(block[data_start : data_start + total_size])
    src2 = bytes(block[data_start + total_size : data_start + 2 * total_size])
    blit_with_wrapping_mask(buf1, src1, block_width, block_height, mask, mask_width, mask_height, False)
    blit_with_wrapping_mask(buf1, src2, block_width, block_height, mask, mask_width, mask_height, True)
    blit_with_wrapping_mask(buf2, src1, block_width, block_height, mask, mask_width, mask_height, True)
    blit_with_wrapping_mask(buf2, src2, block_width, block_height, mask, mask_width, mask_height, False)
    combined = bytearray(compressed_size)
    combined[:half_size] = buf1[:half_size]
    combined[half_size:compressed_size] = buf2[:compressed_size - half_size]
    xor_decrypt_inplace(combined, TABLE_DF70, 173, compressed_size)
    result = lzss_decompress(bytes(combined))
    return filename, result

def parse_pck_header(data: bytes) -> dict:
    header = struct.unpack_from('<23I', data, 0)
    offset17 = header[17]
    offset19 = header[19]
    file_count = header[20]
    dir_block_size = header[22]
    offset_val1_pos = 8 * file_count - 4 + offset17
    offset_val2_pos = 8 * file_count - 8 + offset17
    val1 = struct.unpack_from('<I', data, offset_val1_pos)[0]
    val2 = struct.unpack_from('<I', data, offset_val2_pos)[0]
    first_block_offset = offset19 + val1 + val2
    return {
        'offset17': offset17,
        'offset19': offset19,
        'file_count': file_count,
        'dir_block_size': dir_block_size,
        'first_block_offset': first_block_offset,
    }

def extract_pck(input_pck: str, output_dir: str) -> bool:
    if not os.path.exists(input_pck):
        print(f"Error: Input file not found: {input_pck}")
        return False
    mtime = os.path.getmtime(input_pck)
    dt = datetime.fromtimestamp(mtime)
    subdir_name = f"ss_{dt.strftime('%Y%m%d_%H%M%S')}"
    with open(input_pck, 'rb') as f:
        data = bytearray(f.read())
    print(f"File size: {len(data)} bytes")
    header_info = parse_pck_header(data)
    print(f"Header info: {header_info}")
    dir_offset = header_info['first_block_offset']
    dir_size = header_info['dir_block_size']
    print(f"Directory block at offset {dir_offset}, size {dir_size}")
    dir_block = bytearray(data[dir_offset : dir_offset + dir_size])
    _, dir_data = decrypt_and_decompress_resource(dir_block, dir_size)
    num_files = len(dir_data) // 4
    file_sizes = struct.unpack(f'<{num_files}I', dir_data)
    print(f"Found {num_files} files")
    file_offset = dir_offset + dir_size
    for i, file_size in enumerate(file_sizes):
        file_block = bytearray(data[file_offset : file_offset + file_size])
        filename, file_data = decrypt_and_decompress_resource(file_block, file_size)
        out_path = os.path.join(output_dir, subdir_name, filename)
        out_dir = os.path.dirname(out_path)
        os.makedirs(out_dir, exist_ok=True)
        with open(out_path, 'wb') as f:
            f.write(file_data)
        file_offset += file_size
    return True

def main():
    if len(sys.argv) < 3:
        print("Usage: python pck_extract.py <input.pck> <output_dir>")
        sys.exit(1)
    input_pck = sys.argv[1]
    output_dir = sys.argv[2]
    if extract_pck(input_pck, output_dir):
        print("\nDone!")
    else:
        print("\nFailed!")
        sys.exit(1)

if __name__ == "__main__":
    main()